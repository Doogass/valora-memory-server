import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';

// User roles and permissions
export enum UserRole {
  ADMIN = 'admin',
  USER = 'user',
  READONLY = 'readonly',
}

export interface User {
  id: string;
  email: string;
  role: UserRole;
  permissions: string[];
  createdAt: Date;
  lastLogin: Date;
}

interface Session {
  userId: string;
  expiresAt: Date;
}

interface Attempt {
  count: number;
  lastAttempt: Date;
}

class BruteForceProtection {
  private attempts: Map<string, Attempt> = new Map();
  private sessions: Map<string, Session> = new Map();
  private maxAttempts: number;
  private blockDuration: number;
  private windowMs: number;

  constructor(maxAttempts = 5, blockDuration = 15 * 60 * 1000, windowMs = 15 * 60 * 1000) {
    this.maxAttempts = maxAttempts;
    this.blockDuration = blockDuration;
    this.windowMs = windowMs;
  }

  isBlocked(identifier: string): boolean {
    const attempt = this.attempts.get(identifier);
    if (!attempt) {
      return false;
    }

    const now = new Date();
    const timeSinceLastAttempt = now.getTime() - attempt.lastAttempt.getTime();

    // Reset if window has passed
    if (timeSinceLastAttempt > this.windowMs) {
      this.attempts.delete(identifier);
      return false;
    }

    // Check if blocked
    if (attempt.count >= this.maxAttempts) {
      const timeSinceBlock = now.getTime() - attempt.lastAttempt.getTime();
      if (timeSinceBlock < this.blockDuration) {
        return true;
      } else {
        // Unblock after duration
        this.attempts.delete(identifier);
        return false;
      }
    }

    return false;
  }

  recordFailedAttempt(identifier: string): void {
    const now = new Date();
    const attempt = this.attempts.get(identifier);

    if (attempt) {
      const timeSinceLastAttempt = now.getTime() - attempt.lastAttempt.getTime();
      if (timeSinceLastAttempt > this.windowMs) {
        // Reset if window has passed
        this.attempts.set(identifier, { count: 1, lastAttempt: now });
      } else {
        // Increment count
        this.attempts.set(identifier, { count: attempt.count + 1, lastAttempt: now });
      }
    } else {
      // First attempt
      this.attempts.set(identifier, { count: 1, lastAttempt: now });
    }

    this.cleanupSessions();
  }

  recordSuccessfulAttempt(identifier: string): void {
    this.attempts.delete(identifier);
  }

  createSession(userId: string, sessionId: string, expiresAt: Date): void {
    this.sessions.set(sessionId, { userId, expiresAt });
    this.cleanupSessions();
  }

  getSession(sessionId: string): Session | undefined {
    const session = this.sessions.get(sessionId);
    if (session) {
      const now = new Date();
      if (now > session.expiresAt) {
        this.sessions.delete(sessionId);
        return undefined;
      }
      return session;
    }
    return undefined;
  }

  private cleanupSessions(): void {
    const now = new Date();
    for (const [sessionId, session] of this.sessions.entries()) {
      if (now > session.expiresAt) {
        this.sessions.delete(sessionId);
      }
    }
  }

  isBlockedByIP(ip: string): boolean {
    return this.isBlocked(`ip:${ip}`);
  }

  recordFailedAttemptByIP(ip: string): void {
    this.recordFailedAttempt(`ip:${ip}`);
  }

  recordSuccessfulAttemptByIP(ip: string): void {
    this.recordSuccessfulAttempt(`ip:${ip}`);
  }
}

export const bruteForceProtection = new BruteForceProtection();

// Enhanced authentication middleware
export const authenticateToken = (req: Request, res: Response, next: NextFunction): void => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    res.status(401).json({ error: 'Access token required' });
    return;
  }

  const token = authHeader.split(' ')[1];

  try {
    const decoded = verifyToken(token);
    (req as any).user = decoded;
    next();
  } catch (error) {
    res.status(403).json({ error: 'Invalid or expired token' });
  }
};

// Role-based access control
export const requireRole = (roles: UserRole[]) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    const user = (req as any).user;
    
    if (!user) {
      res.status(401).json({ error: 'Authentication required' });
      return;
    }

    if (!roles.includes(user.role)) {
      res.status(403).json({ error: 'Insufficient permissions' });
      return;
    }

    next();
  };
};

// Permission-based access control
export const requirePermission = (permission: string) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    const user = (req as any).user;
    
    if (!user) {
      res.status(401).json({ error: 'Authentication required' });
      return;
    }

    if (!user.permissions.includes(permission)) {
      res.status(403).json({ error: 'Insufficient permissions' });
      return;
    }

    next();
  };
};

// API Key Authentication Middleware
export const apiKeyAuth = (req: Request, res: Response, next: NextFunction): void => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    res.status(401).json({ error: 'Missing or invalid authorization header' });
    return;
  }

  const apiKey = authHeader.substring(7); // Remove 'Bearer ' prefix
  const expectedApiKey = process.env.VALORA_API_KEY;

  if (!expectedApiKey) {
    console.error('VALORA_API_KEY environment variable not set');
    res.status(500).json({ error: 'Server configuration error' });
    return;
  }

  if (apiKey !== expectedApiKey) {
    const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
    bruteForceProtection.recordFailedAttemptByIP(clientIP);
    
    res.status(401).json({ error: 'Invalid API key' });
    return;
  }

  // Record successful authentication
  const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
  bruteForceProtection.recordSuccessfulAttemptByIP(clientIP);

  // Add user info to request
  (req as any).user = { type: 'api-key', id: 'api-user' };
  
  next();
};

// JWT Token Generation (for future use)
export const generateToken = (payload: any, expiresIn = '24h'): string => {
  const secret = process.env.VALORA_JWT_SECRET || 'fallback-secret';
  return jwt.sign(payload, secret, { expiresIn } as jwt.SignOptions);
};

// JWT Token Verification (for future use)
export const verifyToken = (token: string): any => {
  const secret = process.env.VALORA_JWT_SECRET || 'fallback-secret';
  return jwt.verify(token, secret);
};

// Session management
export const sessionManager = {
  sessions: new Map<string, { userId: string; expiresAt: Date }>(),

  createSession: (userId: string): string => {
    const sessionId = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours
    
    this.sessions.set(sessionId, { userId, expiresAt });
    
    // Clean up expired sessions
    this.cleanupSessions();
    
    return sessionId;
  },

  validateSession: (sessionId: string): string | null => {
    const session = this.sessions.get(sessionId);
    
    if (!session || session.expiresAt < new Date()) {
      this.sessions.delete(sessionId);
      return null;
    }
    
    return session.userId;
  },

  cleanupSessions: (): void => {
    const now = new Date();
    for (const [sessionId, session] of this.sessions.entries()) {
      if (session.expiresAt < now) {
        this.sessions.delete(sessionId);
      }
    }
  },
};
